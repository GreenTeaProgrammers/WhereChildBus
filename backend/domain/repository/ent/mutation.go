// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/GreenTeaProgrammers/WhereChildBus/backend/domain/repository/ent/boardingrecord"
	"github.com/GreenTeaProgrammers/WhereChildBus/backend/domain/repository/ent/bus"
	"github.com/GreenTeaProgrammers/WhereChildBus/backend/domain/repository/ent/child"
	"github.com/GreenTeaProgrammers/WhereChildBus/backend/domain/repository/ent/childbusassociation"
	"github.com/GreenTeaProgrammers/WhereChildBus/backend/domain/repository/ent/childphoto"
	"github.com/GreenTeaProgrammers/WhereChildBus/backend/domain/repository/ent/guardian"
	"github.com/GreenTeaProgrammers/WhereChildBus/backend/domain/repository/ent/nursery"
	"github.com/GreenTeaProgrammers/WhereChildBus/backend/domain/repository/ent/predicate"
	"github.com/GreenTeaProgrammers/WhereChildBus/backend/domain/repository/ent/station"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBoardingRecord      = "BoardingRecord"
	TypeBus                 = "Bus"
	TypeChild               = "Child"
	TypeChildBusAssociation = "ChildBusAssociation"
	TypeChildPhoto          = "ChildPhoto"
	TypeGuardian            = "Guardian"
	TypeNursery             = "Nursery"
	TypeStation             = "Station"
)

// BoardingRecordMutation represents an operation that mutates the BoardingRecord nodes in the graph.
type BoardingRecordMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	timestamp     *time.Time
	is_boarding   *bool
	clearedFields map[string]struct{}
	child         *uuid.UUID
	clearedchild  bool
	bus           *uuid.UUID
	clearedbus    bool
	done          bool
	oldValue      func(context.Context) (*BoardingRecord, error)
	predicates    []predicate.BoardingRecord
}

var _ ent.Mutation = (*BoardingRecordMutation)(nil)

// boardingrecordOption allows management of the mutation configuration using functional options.
type boardingrecordOption func(*BoardingRecordMutation)

// newBoardingRecordMutation creates new mutation for the BoardingRecord entity.
func newBoardingRecordMutation(c config, op Op, opts ...boardingrecordOption) *BoardingRecordMutation {
	m := &BoardingRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeBoardingRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBoardingRecordID sets the ID field of the mutation.
func withBoardingRecordID(id uuid.UUID) boardingrecordOption {
	return func(m *BoardingRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *BoardingRecord
		)
		m.oldValue = func(ctx context.Context) (*BoardingRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BoardingRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBoardingRecord sets the old BoardingRecord of the mutation.
func withBoardingRecord(node *BoardingRecord) boardingrecordOption {
	return func(m *BoardingRecordMutation) {
		m.oldValue = func(context.Context) (*BoardingRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BoardingRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BoardingRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BoardingRecord entities.
func (m *BoardingRecordMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BoardingRecordMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BoardingRecordMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BoardingRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTimestamp sets the "timestamp" field.
func (m *BoardingRecordMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *BoardingRecordMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the BoardingRecord entity.
// If the BoardingRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardingRecordMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *BoardingRecordMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetIsBoarding sets the "is_boarding" field.
func (m *BoardingRecordMutation) SetIsBoarding(b bool) {
	m.is_boarding = &b
}

// IsBoarding returns the value of the "is_boarding" field in the mutation.
func (m *BoardingRecordMutation) IsBoarding() (r bool, exists bool) {
	v := m.is_boarding
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBoarding returns the old "is_boarding" field's value of the BoardingRecord entity.
// If the BoardingRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardingRecordMutation) OldIsBoarding(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBoarding is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBoarding requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBoarding: %w", err)
	}
	return oldValue.IsBoarding, nil
}

// ResetIsBoarding resets all changes to the "is_boarding" field.
func (m *BoardingRecordMutation) ResetIsBoarding() {
	m.is_boarding = nil
}

// SetChildID sets the "child" edge to the Child entity by id.
func (m *BoardingRecordMutation) SetChildID(id uuid.UUID) {
	m.child = &id
}

// ClearChild clears the "child" edge to the Child entity.
func (m *BoardingRecordMutation) ClearChild() {
	m.clearedchild = true
}

// ChildCleared reports if the "child" edge to the Child entity was cleared.
func (m *BoardingRecordMutation) ChildCleared() bool {
	return m.clearedchild
}

// ChildID returns the "child" edge ID in the mutation.
func (m *BoardingRecordMutation) ChildID() (id uuid.UUID, exists bool) {
	if m.child != nil {
		return *m.child, true
	}
	return
}

// ChildIDs returns the "child" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChildID instead. It exists only for internal usage by the builders.
func (m *BoardingRecordMutation) ChildIDs() (ids []uuid.UUID) {
	if id := m.child; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChild resets all changes to the "child" edge.
func (m *BoardingRecordMutation) ResetChild() {
	m.child = nil
	m.clearedchild = false
}

// SetBusID sets the "bus" edge to the Bus entity by id.
func (m *BoardingRecordMutation) SetBusID(id uuid.UUID) {
	m.bus = &id
}

// ClearBus clears the "bus" edge to the Bus entity.
func (m *BoardingRecordMutation) ClearBus() {
	m.clearedbus = true
}

// BusCleared reports if the "bus" edge to the Bus entity was cleared.
func (m *BoardingRecordMutation) BusCleared() bool {
	return m.clearedbus
}

// BusID returns the "bus" edge ID in the mutation.
func (m *BoardingRecordMutation) BusID() (id uuid.UUID, exists bool) {
	if m.bus != nil {
		return *m.bus, true
	}
	return
}

// BusIDs returns the "bus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusID instead. It exists only for internal usage by the builders.
func (m *BoardingRecordMutation) BusIDs() (ids []uuid.UUID) {
	if id := m.bus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBus resets all changes to the "bus" edge.
func (m *BoardingRecordMutation) ResetBus() {
	m.bus = nil
	m.clearedbus = false
}

// Where appends a list predicates to the BoardingRecordMutation builder.
func (m *BoardingRecordMutation) Where(ps ...predicate.BoardingRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BoardingRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BoardingRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BoardingRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BoardingRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BoardingRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BoardingRecord).
func (m *BoardingRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BoardingRecordMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.timestamp != nil {
		fields = append(fields, boardingrecord.FieldTimestamp)
	}
	if m.is_boarding != nil {
		fields = append(fields, boardingrecord.FieldIsBoarding)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BoardingRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case boardingrecord.FieldTimestamp:
		return m.Timestamp()
	case boardingrecord.FieldIsBoarding:
		return m.IsBoarding()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BoardingRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case boardingrecord.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case boardingrecord.FieldIsBoarding:
		return m.OldIsBoarding(ctx)
	}
	return nil, fmt.Errorf("unknown BoardingRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BoardingRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case boardingrecord.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case boardingrecord.FieldIsBoarding:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBoarding(v)
		return nil
	}
	return fmt.Errorf("unknown BoardingRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BoardingRecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BoardingRecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BoardingRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BoardingRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BoardingRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BoardingRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BoardingRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BoardingRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BoardingRecordMutation) ResetField(name string) error {
	switch name {
	case boardingrecord.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case boardingrecord.FieldIsBoarding:
		m.ResetIsBoarding()
		return nil
	}
	return fmt.Errorf("unknown BoardingRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BoardingRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.child != nil {
		edges = append(edges, boardingrecord.EdgeChild)
	}
	if m.bus != nil {
		edges = append(edges, boardingrecord.EdgeBus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BoardingRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case boardingrecord.EdgeChild:
		if id := m.child; id != nil {
			return []ent.Value{*id}
		}
	case boardingrecord.EdgeBus:
		if id := m.bus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BoardingRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BoardingRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BoardingRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchild {
		edges = append(edges, boardingrecord.EdgeChild)
	}
	if m.clearedbus {
		edges = append(edges, boardingrecord.EdgeBus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BoardingRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case boardingrecord.EdgeChild:
		return m.clearedchild
	case boardingrecord.EdgeBus:
		return m.clearedbus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BoardingRecordMutation) ClearEdge(name string) error {
	switch name {
	case boardingrecord.EdgeChild:
		m.ClearChild()
		return nil
	case boardingrecord.EdgeBus:
		m.ClearBus()
		return nil
	}
	return fmt.Errorf("unknown BoardingRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BoardingRecordMutation) ResetEdge(name string) error {
	switch name {
	case boardingrecord.EdgeChild:
		m.ResetChild()
		return nil
	case boardingrecord.EdgeBus:
		m.ResetBus()
		return nil
	}
	return fmt.Errorf("unknown BoardingRecord edge %s", name)
}

// BusMutation represents an operation that mutates the Bus nodes in the graph.
type BusMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	name                        *string
	plate_number                *string
	latitude                    *float64
	addlatitude                 *float64
	longitude                   *float64
	addlongitude                *float64
	status                      *bus.Status
	created_at                  *time.Time
	updated_at                  *time.Time
	clearedFields               map[string]struct{}
	nursery                     *uuid.UUID
	clearednursery              bool
	stations                    map[uuid.UUID]struct{}
	removedstations             map[uuid.UUID]struct{}
	clearedstations             bool
	boarding_records            map[uuid.UUID]struct{}
	removedboarding_records     map[uuid.UUID]struct{}
	clearedboarding_records     bool
	childBusAssociations        map[int]struct{}
	removedchildBusAssociations map[int]struct{}
	clearedchildBusAssociations bool
	done                        bool
	oldValue                    func(context.Context) (*Bus, error)
	predicates                  []predicate.Bus
}

var _ ent.Mutation = (*BusMutation)(nil)

// busOption allows management of the mutation configuration using functional options.
type busOption func(*BusMutation)

// newBusMutation creates new mutation for the Bus entity.
func newBusMutation(c config, op Op, opts ...busOption) *BusMutation {
	m := &BusMutation{
		config:        c,
		op:            op,
		typ:           TypeBus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusID sets the ID field of the mutation.
func withBusID(id uuid.UUID) busOption {
	return func(m *BusMutation) {
		var (
			err   error
			once  sync.Once
			value *Bus
		)
		m.oldValue = func(ctx context.Context) (*Bus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBus sets the old Bus of the mutation.
func withBus(node *Bus) busOption {
	return func(m *BusMutation) {
		m.oldValue = func(context.Context) (*Bus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bus entities.
func (m *BusMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BusMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BusMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Bus entity.
// If the Bus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BusMutation) ResetName() {
	m.name = nil
}

// SetPlateNumber sets the "plate_number" field.
func (m *BusMutation) SetPlateNumber(s string) {
	m.plate_number = &s
}

// PlateNumber returns the value of the "plate_number" field in the mutation.
func (m *BusMutation) PlateNumber() (r string, exists bool) {
	v := m.plate_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPlateNumber returns the old "plate_number" field's value of the Bus entity.
// If the Bus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusMutation) OldPlateNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlateNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlateNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlateNumber: %w", err)
	}
	return oldValue.PlateNumber, nil
}

// ClearPlateNumber clears the value of the "plate_number" field.
func (m *BusMutation) ClearPlateNumber() {
	m.plate_number = nil
	m.clearedFields[bus.FieldPlateNumber] = struct{}{}
}

// PlateNumberCleared returns if the "plate_number" field was cleared in this mutation.
func (m *BusMutation) PlateNumberCleared() bool {
	_, ok := m.clearedFields[bus.FieldPlateNumber]
	return ok
}

// ResetPlateNumber resets all changes to the "plate_number" field.
func (m *BusMutation) ResetPlateNumber() {
	m.plate_number = nil
	delete(m.clearedFields, bus.FieldPlateNumber)
}

// SetLatitude sets the "latitude" field.
func (m *BusMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *BusMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Bus entity.
// If the Bus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *BusMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *BusMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *BusMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[bus.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *BusMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[bus.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *BusMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, bus.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *BusMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *BusMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Bus entity.
// If the Bus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *BusMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *BusMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *BusMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[bus.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *BusMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[bus.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *BusMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, bus.FieldLongitude)
}

// SetStatus sets the "status" field.
func (m *BusMutation) SetStatus(b bus.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BusMutation) Status() (r bus.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Bus entity.
// If the Bus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusMutation) OldStatus(ctx context.Context) (v bus.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BusMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bus entity.
// If the Bus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Bus entity.
// If the Bus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetNurseryID sets the "nursery" edge to the Nursery entity by id.
func (m *BusMutation) SetNurseryID(id uuid.UUID) {
	m.nursery = &id
}

// ClearNursery clears the "nursery" edge to the Nursery entity.
func (m *BusMutation) ClearNursery() {
	m.clearednursery = true
}

// NurseryCleared reports if the "nursery" edge to the Nursery entity was cleared.
func (m *BusMutation) NurseryCleared() bool {
	return m.clearednursery
}

// NurseryID returns the "nursery" edge ID in the mutation.
func (m *BusMutation) NurseryID() (id uuid.UUID, exists bool) {
	if m.nursery != nil {
		return *m.nursery, true
	}
	return
}

// NurseryIDs returns the "nursery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NurseryID instead. It exists only for internal usage by the builders.
func (m *BusMutation) NurseryIDs() (ids []uuid.UUID) {
	if id := m.nursery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNursery resets all changes to the "nursery" edge.
func (m *BusMutation) ResetNursery() {
	m.nursery = nil
	m.clearednursery = false
}

// AddStationIDs adds the "stations" edge to the Station entity by ids.
func (m *BusMutation) AddStationIDs(ids ...uuid.UUID) {
	if m.stations == nil {
		m.stations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.stations[ids[i]] = struct{}{}
	}
}

// ClearStations clears the "stations" edge to the Station entity.
func (m *BusMutation) ClearStations() {
	m.clearedstations = true
}

// StationsCleared reports if the "stations" edge to the Station entity was cleared.
func (m *BusMutation) StationsCleared() bool {
	return m.clearedstations
}

// RemoveStationIDs removes the "stations" edge to the Station entity by IDs.
func (m *BusMutation) RemoveStationIDs(ids ...uuid.UUID) {
	if m.removedstations == nil {
		m.removedstations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.stations, ids[i])
		m.removedstations[ids[i]] = struct{}{}
	}
}

// RemovedStations returns the removed IDs of the "stations" edge to the Station entity.
func (m *BusMutation) RemovedStationsIDs() (ids []uuid.UUID) {
	for id := range m.removedstations {
		ids = append(ids, id)
	}
	return
}

// StationsIDs returns the "stations" edge IDs in the mutation.
func (m *BusMutation) StationsIDs() (ids []uuid.UUID) {
	for id := range m.stations {
		ids = append(ids, id)
	}
	return
}

// ResetStations resets all changes to the "stations" edge.
func (m *BusMutation) ResetStations() {
	m.stations = nil
	m.clearedstations = false
	m.removedstations = nil
}

// AddBoardingRecordIDs adds the "boarding_records" edge to the BoardingRecord entity by ids.
func (m *BusMutation) AddBoardingRecordIDs(ids ...uuid.UUID) {
	if m.boarding_records == nil {
		m.boarding_records = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.boarding_records[ids[i]] = struct{}{}
	}
}

// ClearBoardingRecords clears the "boarding_records" edge to the BoardingRecord entity.
func (m *BusMutation) ClearBoardingRecords() {
	m.clearedboarding_records = true
}

// BoardingRecordsCleared reports if the "boarding_records" edge to the BoardingRecord entity was cleared.
func (m *BusMutation) BoardingRecordsCleared() bool {
	return m.clearedboarding_records
}

// RemoveBoardingRecordIDs removes the "boarding_records" edge to the BoardingRecord entity by IDs.
func (m *BusMutation) RemoveBoardingRecordIDs(ids ...uuid.UUID) {
	if m.removedboarding_records == nil {
		m.removedboarding_records = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.boarding_records, ids[i])
		m.removedboarding_records[ids[i]] = struct{}{}
	}
}

// RemovedBoardingRecords returns the removed IDs of the "boarding_records" edge to the BoardingRecord entity.
func (m *BusMutation) RemovedBoardingRecordsIDs() (ids []uuid.UUID) {
	for id := range m.removedboarding_records {
		ids = append(ids, id)
	}
	return
}

// BoardingRecordsIDs returns the "boarding_records" edge IDs in the mutation.
func (m *BusMutation) BoardingRecordsIDs() (ids []uuid.UUID) {
	for id := range m.boarding_records {
		ids = append(ids, id)
	}
	return
}

// ResetBoardingRecords resets all changes to the "boarding_records" edge.
func (m *BusMutation) ResetBoardingRecords() {
	m.boarding_records = nil
	m.clearedboarding_records = false
	m.removedboarding_records = nil
}

// AddChildBusAssociationIDs adds the "childBusAssociations" edge to the ChildBusAssociation entity by ids.
func (m *BusMutation) AddChildBusAssociationIDs(ids ...int) {
	if m.childBusAssociations == nil {
		m.childBusAssociations = make(map[int]struct{})
	}
	for i := range ids {
		m.childBusAssociations[ids[i]] = struct{}{}
	}
}

// ClearChildBusAssociations clears the "childBusAssociations" edge to the ChildBusAssociation entity.
func (m *BusMutation) ClearChildBusAssociations() {
	m.clearedchildBusAssociations = true
}

// ChildBusAssociationsCleared reports if the "childBusAssociations" edge to the ChildBusAssociation entity was cleared.
func (m *BusMutation) ChildBusAssociationsCleared() bool {
	return m.clearedchildBusAssociations
}

// RemoveChildBusAssociationIDs removes the "childBusAssociations" edge to the ChildBusAssociation entity by IDs.
func (m *BusMutation) RemoveChildBusAssociationIDs(ids ...int) {
	if m.removedchildBusAssociations == nil {
		m.removedchildBusAssociations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.childBusAssociations, ids[i])
		m.removedchildBusAssociations[ids[i]] = struct{}{}
	}
}

// RemovedChildBusAssociations returns the removed IDs of the "childBusAssociations" edge to the ChildBusAssociation entity.
func (m *BusMutation) RemovedChildBusAssociationsIDs() (ids []int) {
	for id := range m.removedchildBusAssociations {
		ids = append(ids, id)
	}
	return
}

// ChildBusAssociationsIDs returns the "childBusAssociations" edge IDs in the mutation.
func (m *BusMutation) ChildBusAssociationsIDs() (ids []int) {
	for id := range m.childBusAssociations {
		ids = append(ids, id)
	}
	return
}

// ResetChildBusAssociations resets all changes to the "childBusAssociations" edge.
func (m *BusMutation) ResetChildBusAssociations() {
	m.childBusAssociations = nil
	m.clearedchildBusAssociations = false
	m.removedchildBusAssociations = nil
}

// Where appends a list predicates to the BusMutation builder.
func (m *BusMutation) Where(ps ...predicate.Bus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bus).
func (m *BusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, bus.FieldName)
	}
	if m.plate_number != nil {
		fields = append(fields, bus.FieldPlateNumber)
	}
	if m.latitude != nil {
		fields = append(fields, bus.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, bus.FieldLongitude)
	}
	if m.status != nil {
		fields = append(fields, bus.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, bus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bus.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bus.FieldName:
		return m.Name()
	case bus.FieldPlateNumber:
		return m.PlateNumber()
	case bus.FieldLatitude:
		return m.Latitude()
	case bus.FieldLongitude:
		return m.Longitude()
	case bus.FieldStatus:
		return m.Status()
	case bus.FieldCreatedAt:
		return m.CreatedAt()
	case bus.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bus.FieldName:
		return m.OldName(ctx)
	case bus.FieldPlateNumber:
		return m.OldPlateNumber(ctx)
	case bus.FieldLatitude:
		return m.OldLatitude(ctx)
	case bus.FieldLongitude:
		return m.OldLongitude(ctx)
	case bus.FieldStatus:
		return m.OldStatus(ctx)
	case bus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Bus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bus.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bus.FieldPlateNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlateNumber(v)
		return nil
	case bus.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case bus.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case bus.FieldStatus:
		v, ok := value.(bus.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Bus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, bus.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, bus.FieldLongitude)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bus.FieldLatitude:
		return m.AddedLatitude()
	case bus.FieldLongitude:
		return m.AddedLongitude()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bus.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case bus.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown Bus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bus.FieldPlateNumber) {
		fields = append(fields, bus.FieldPlateNumber)
	}
	if m.FieldCleared(bus.FieldLatitude) {
		fields = append(fields, bus.FieldLatitude)
	}
	if m.FieldCleared(bus.FieldLongitude) {
		fields = append(fields, bus.FieldLongitude)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusMutation) ClearField(name string) error {
	switch name {
	case bus.FieldPlateNumber:
		m.ClearPlateNumber()
		return nil
	case bus.FieldLatitude:
		m.ClearLatitude()
		return nil
	case bus.FieldLongitude:
		m.ClearLongitude()
		return nil
	}
	return fmt.Errorf("unknown Bus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusMutation) ResetField(name string) error {
	switch name {
	case bus.FieldName:
		m.ResetName()
		return nil
	case bus.FieldPlateNumber:
		m.ResetPlateNumber()
		return nil
	case bus.FieldLatitude:
		m.ResetLatitude()
		return nil
	case bus.FieldLongitude:
		m.ResetLongitude()
		return nil
	case bus.FieldStatus:
		m.ResetStatus()
		return nil
	case bus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Bus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.nursery != nil {
		edges = append(edges, bus.EdgeNursery)
	}
	if m.stations != nil {
		edges = append(edges, bus.EdgeStations)
	}
	if m.boarding_records != nil {
		edges = append(edges, bus.EdgeBoardingRecords)
	}
	if m.childBusAssociations != nil {
		edges = append(edges, bus.EdgeChildBusAssociations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bus.EdgeNursery:
		if id := m.nursery; id != nil {
			return []ent.Value{*id}
		}
	case bus.EdgeStations:
		ids := make([]ent.Value, 0, len(m.stations))
		for id := range m.stations {
			ids = append(ids, id)
		}
		return ids
	case bus.EdgeBoardingRecords:
		ids := make([]ent.Value, 0, len(m.boarding_records))
		for id := range m.boarding_records {
			ids = append(ids, id)
		}
		return ids
	case bus.EdgeChildBusAssociations:
		ids := make([]ent.Value, 0, len(m.childBusAssociations))
		for id := range m.childBusAssociations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedstations != nil {
		edges = append(edges, bus.EdgeStations)
	}
	if m.removedboarding_records != nil {
		edges = append(edges, bus.EdgeBoardingRecords)
	}
	if m.removedchildBusAssociations != nil {
		edges = append(edges, bus.EdgeChildBusAssociations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bus.EdgeStations:
		ids := make([]ent.Value, 0, len(m.removedstations))
		for id := range m.removedstations {
			ids = append(ids, id)
		}
		return ids
	case bus.EdgeBoardingRecords:
		ids := make([]ent.Value, 0, len(m.removedboarding_records))
		for id := range m.removedboarding_records {
			ids = append(ids, id)
		}
		return ids
	case bus.EdgeChildBusAssociations:
		ids := make([]ent.Value, 0, len(m.removedchildBusAssociations))
		for id := range m.removedchildBusAssociations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearednursery {
		edges = append(edges, bus.EdgeNursery)
	}
	if m.clearedstations {
		edges = append(edges, bus.EdgeStations)
	}
	if m.clearedboarding_records {
		edges = append(edges, bus.EdgeBoardingRecords)
	}
	if m.clearedchildBusAssociations {
		edges = append(edges, bus.EdgeChildBusAssociations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusMutation) EdgeCleared(name string) bool {
	switch name {
	case bus.EdgeNursery:
		return m.clearednursery
	case bus.EdgeStations:
		return m.clearedstations
	case bus.EdgeBoardingRecords:
		return m.clearedboarding_records
	case bus.EdgeChildBusAssociations:
		return m.clearedchildBusAssociations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusMutation) ClearEdge(name string) error {
	switch name {
	case bus.EdgeNursery:
		m.ClearNursery()
		return nil
	}
	return fmt.Errorf("unknown Bus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusMutation) ResetEdge(name string) error {
	switch name {
	case bus.EdgeNursery:
		m.ResetNursery()
		return nil
	case bus.EdgeStations:
		m.ResetStations()
		return nil
	case bus.EdgeBoardingRecords:
		m.ResetBoardingRecords()
		return nil
	case bus.EdgeChildBusAssociations:
		m.ResetChildBusAssociations()
		return nil
	}
	return fmt.Errorf("unknown Bus edge %s", name)
}

// ChildMutation represents an operation that mutates the Child nodes in the graph.
type ChildMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	name                        *string
	age                         *int
	addage                      *int
	sex                         *child.Sex
	is_ride_morning_bus         *bool
	is_ride_evening_bus         *bool
	check_for_missing_items     *bool
	has_bag                     *bool
	has_lunch_box               *bool
	has_water_bottle            *bool
	has_umbrella                *bool
	has_other                   *bool
	created_at                  *time.Time
	updated_at                  *time.Time
	clearedFields               map[string]struct{}
	guardian                    *uuid.UUID
	clearedguardian             bool
	childBusAssociations        map[int]struct{}
	removedchildBusAssociations map[int]struct{}
	clearedchildBusAssociations bool
	nursery                     *uuid.UUID
	clearednursery              bool
	boarding_record             map[uuid.UUID]struct{}
	removedboarding_record      map[uuid.UUID]struct{}
	clearedboarding_record      bool
	photos                      map[uuid.UUID]struct{}
	removedphotos               map[uuid.UUID]struct{}
	clearedphotos               bool
	done                        bool
	oldValue                    func(context.Context) (*Child, error)
	predicates                  []predicate.Child
}

var _ ent.Mutation = (*ChildMutation)(nil)

// childOption allows management of the mutation configuration using functional options.
type childOption func(*ChildMutation)

// newChildMutation creates new mutation for the Child entity.
func newChildMutation(c config, op Op, opts ...childOption) *ChildMutation {
	m := &ChildMutation{
		config:        c,
		op:            op,
		typ:           TypeChild,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChildID sets the ID field of the mutation.
func withChildID(id uuid.UUID) childOption {
	return func(m *ChildMutation) {
		var (
			err   error
			once  sync.Once
			value *Child
		)
		m.oldValue = func(ctx context.Context) (*Child, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Child.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChild sets the old Child of the mutation.
func withChild(node *Child) childOption {
	return func(m *ChildMutation) {
		m.oldValue = func(context.Context) (*Child, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChildMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChildMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Child entities.
func (m *ChildMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChildMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChildMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Child.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ChildMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChildMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Child entity.
// If the Child object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChildMutation) ResetName() {
	m.name = nil
}

// SetAge sets the "age" field.
func (m *ChildMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *ChildMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Child entity.
// If the Child object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *ChildMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *ChildMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *ChildMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetSex sets the "sex" field.
func (m *ChildMutation) SetSex(c child.Sex) {
	m.sex = &c
}

// Sex returns the value of the "sex" field in the mutation.
func (m *ChildMutation) Sex() (r child.Sex, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the Child entity.
// If the Child object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildMutation) OldSex(ctx context.Context) (v child.Sex, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ResetSex resets all changes to the "sex" field.
func (m *ChildMutation) ResetSex() {
	m.sex = nil
}

// SetIsRideMorningBus sets the "is_ride_morning_bus" field.
func (m *ChildMutation) SetIsRideMorningBus(b bool) {
	m.is_ride_morning_bus = &b
}

// IsRideMorningBus returns the value of the "is_ride_morning_bus" field in the mutation.
func (m *ChildMutation) IsRideMorningBus() (r bool, exists bool) {
	v := m.is_ride_morning_bus
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRideMorningBus returns the old "is_ride_morning_bus" field's value of the Child entity.
// If the Child object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildMutation) OldIsRideMorningBus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRideMorningBus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRideMorningBus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRideMorningBus: %w", err)
	}
	return oldValue.IsRideMorningBus, nil
}

// ResetIsRideMorningBus resets all changes to the "is_ride_morning_bus" field.
func (m *ChildMutation) ResetIsRideMorningBus() {
	m.is_ride_morning_bus = nil
}

// SetIsRideEveningBus sets the "is_ride_evening_bus" field.
func (m *ChildMutation) SetIsRideEveningBus(b bool) {
	m.is_ride_evening_bus = &b
}

// IsRideEveningBus returns the value of the "is_ride_evening_bus" field in the mutation.
func (m *ChildMutation) IsRideEveningBus() (r bool, exists bool) {
	v := m.is_ride_evening_bus
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRideEveningBus returns the old "is_ride_evening_bus" field's value of the Child entity.
// If the Child object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildMutation) OldIsRideEveningBus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRideEveningBus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRideEveningBus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRideEveningBus: %w", err)
	}
	return oldValue.IsRideEveningBus, nil
}

// ResetIsRideEveningBus resets all changes to the "is_ride_evening_bus" field.
func (m *ChildMutation) ResetIsRideEveningBus() {
	m.is_ride_evening_bus = nil
}

// SetCheckForMissingItems sets the "check_for_missing_items" field.
func (m *ChildMutation) SetCheckForMissingItems(b bool) {
	m.check_for_missing_items = &b
}

// CheckForMissingItems returns the value of the "check_for_missing_items" field in the mutation.
func (m *ChildMutation) CheckForMissingItems() (r bool, exists bool) {
	v := m.check_for_missing_items
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckForMissingItems returns the old "check_for_missing_items" field's value of the Child entity.
// If the Child object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildMutation) OldCheckForMissingItems(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckForMissingItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckForMissingItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckForMissingItems: %w", err)
	}
	return oldValue.CheckForMissingItems, nil
}

// ResetCheckForMissingItems resets all changes to the "check_for_missing_items" field.
func (m *ChildMutation) ResetCheckForMissingItems() {
	m.check_for_missing_items = nil
}

// SetHasBag sets the "has_bag" field.
func (m *ChildMutation) SetHasBag(b bool) {
	m.has_bag = &b
}

// HasBag returns the value of the "has_bag" field in the mutation.
func (m *ChildMutation) HasBag() (r bool, exists bool) {
	v := m.has_bag
	if v == nil {
		return
	}
	return *v, true
}

// OldHasBag returns the old "has_bag" field's value of the Child entity.
// If the Child object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildMutation) OldHasBag(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasBag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasBag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasBag: %w", err)
	}
	return oldValue.HasBag, nil
}

// ResetHasBag resets all changes to the "has_bag" field.
func (m *ChildMutation) ResetHasBag() {
	m.has_bag = nil
}

// SetHasLunchBox sets the "has_lunch_box" field.
func (m *ChildMutation) SetHasLunchBox(b bool) {
	m.has_lunch_box = &b
}

// HasLunchBox returns the value of the "has_lunch_box" field in the mutation.
func (m *ChildMutation) HasLunchBox() (r bool, exists bool) {
	v := m.has_lunch_box
	if v == nil {
		return
	}
	return *v, true
}

// OldHasLunchBox returns the old "has_lunch_box" field's value of the Child entity.
// If the Child object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildMutation) OldHasLunchBox(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasLunchBox is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasLunchBox requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasLunchBox: %w", err)
	}
	return oldValue.HasLunchBox, nil
}

// ResetHasLunchBox resets all changes to the "has_lunch_box" field.
func (m *ChildMutation) ResetHasLunchBox() {
	m.has_lunch_box = nil
}

// SetHasWaterBottle sets the "has_water_bottle" field.
func (m *ChildMutation) SetHasWaterBottle(b bool) {
	m.has_water_bottle = &b
}

// HasWaterBottle returns the value of the "has_water_bottle" field in the mutation.
func (m *ChildMutation) HasWaterBottle() (r bool, exists bool) {
	v := m.has_water_bottle
	if v == nil {
		return
	}
	return *v, true
}

// OldHasWaterBottle returns the old "has_water_bottle" field's value of the Child entity.
// If the Child object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildMutation) OldHasWaterBottle(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasWaterBottle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasWaterBottle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasWaterBottle: %w", err)
	}
	return oldValue.HasWaterBottle, nil
}

// ResetHasWaterBottle resets all changes to the "has_water_bottle" field.
func (m *ChildMutation) ResetHasWaterBottle() {
	m.has_water_bottle = nil
}

// SetHasUmbrella sets the "has_umbrella" field.
func (m *ChildMutation) SetHasUmbrella(b bool) {
	m.has_umbrella = &b
}

// HasUmbrella returns the value of the "has_umbrella" field in the mutation.
func (m *ChildMutation) HasUmbrella() (r bool, exists bool) {
	v := m.has_umbrella
	if v == nil {
		return
	}
	return *v, true
}

// OldHasUmbrella returns the old "has_umbrella" field's value of the Child entity.
// If the Child object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildMutation) OldHasUmbrella(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasUmbrella is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasUmbrella requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasUmbrella: %w", err)
	}
	return oldValue.HasUmbrella, nil
}

// ResetHasUmbrella resets all changes to the "has_umbrella" field.
func (m *ChildMutation) ResetHasUmbrella() {
	m.has_umbrella = nil
}

// SetHasOther sets the "has_other" field.
func (m *ChildMutation) SetHasOther(b bool) {
	m.has_other = &b
}

// HasOther returns the value of the "has_other" field in the mutation.
func (m *ChildMutation) HasOther() (r bool, exists bool) {
	v := m.has_other
	if v == nil {
		return
	}
	return *v, true
}

// OldHasOther returns the old "has_other" field's value of the Child entity.
// If the Child object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildMutation) OldHasOther(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasOther is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasOther requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasOther: %w", err)
	}
	return oldValue.HasOther, nil
}

// ResetHasOther resets all changes to the "has_other" field.
func (m *ChildMutation) ResetHasOther() {
	m.has_other = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ChildMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChildMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Child entity.
// If the Child object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChildMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChildMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChildMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Child entity.
// If the Child object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChildMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetGuardianID sets the "guardian" edge to the Guardian entity by id.
func (m *ChildMutation) SetGuardianID(id uuid.UUID) {
	m.guardian = &id
}

// ClearGuardian clears the "guardian" edge to the Guardian entity.
func (m *ChildMutation) ClearGuardian() {
	m.clearedguardian = true
}

// GuardianCleared reports if the "guardian" edge to the Guardian entity was cleared.
func (m *ChildMutation) GuardianCleared() bool {
	return m.clearedguardian
}

// GuardianID returns the "guardian" edge ID in the mutation.
func (m *ChildMutation) GuardianID() (id uuid.UUID, exists bool) {
	if m.guardian != nil {
		return *m.guardian, true
	}
	return
}

// GuardianIDs returns the "guardian" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GuardianID instead. It exists only for internal usage by the builders.
func (m *ChildMutation) GuardianIDs() (ids []uuid.UUID) {
	if id := m.guardian; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGuardian resets all changes to the "guardian" edge.
func (m *ChildMutation) ResetGuardian() {
	m.guardian = nil
	m.clearedguardian = false
}

// AddChildBusAssociationIDs adds the "childBusAssociations" edge to the ChildBusAssociation entity by ids.
func (m *ChildMutation) AddChildBusAssociationIDs(ids ...int) {
	if m.childBusAssociations == nil {
		m.childBusAssociations = make(map[int]struct{})
	}
	for i := range ids {
		m.childBusAssociations[ids[i]] = struct{}{}
	}
}

// ClearChildBusAssociations clears the "childBusAssociations" edge to the ChildBusAssociation entity.
func (m *ChildMutation) ClearChildBusAssociations() {
	m.clearedchildBusAssociations = true
}

// ChildBusAssociationsCleared reports if the "childBusAssociations" edge to the ChildBusAssociation entity was cleared.
func (m *ChildMutation) ChildBusAssociationsCleared() bool {
	return m.clearedchildBusAssociations
}

// RemoveChildBusAssociationIDs removes the "childBusAssociations" edge to the ChildBusAssociation entity by IDs.
func (m *ChildMutation) RemoveChildBusAssociationIDs(ids ...int) {
	if m.removedchildBusAssociations == nil {
		m.removedchildBusAssociations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.childBusAssociations, ids[i])
		m.removedchildBusAssociations[ids[i]] = struct{}{}
	}
}

// RemovedChildBusAssociations returns the removed IDs of the "childBusAssociations" edge to the ChildBusAssociation entity.
func (m *ChildMutation) RemovedChildBusAssociationsIDs() (ids []int) {
	for id := range m.removedchildBusAssociations {
		ids = append(ids, id)
	}
	return
}

// ChildBusAssociationsIDs returns the "childBusAssociations" edge IDs in the mutation.
func (m *ChildMutation) ChildBusAssociationsIDs() (ids []int) {
	for id := range m.childBusAssociations {
		ids = append(ids, id)
	}
	return
}

// ResetChildBusAssociations resets all changes to the "childBusAssociations" edge.
func (m *ChildMutation) ResetChildBusAssociations() {
	m.childBusAssociations = nil
	m.clearedchildBusAssociations = false
	m.removedchildBusAssociations = nil
}

// SetNurseryID sets the "nursery" edge to the Nursery entity by id.
func (m *ChildMutation) SetNurseryID(id uuid.UUID) {
	m.nursery = &id
}

// ClearNursery clears the "nursery" edge to the Nursery entity.
func (m *ChildMutation) ClearNursery() {
	m.clearednursery = true
}

// NurseryCleared reports if the "nursery" edge to the Nursery entity was cleared.
func (m *ChildMutation) NurseryCleared() bool {
	return m.clearednursery
}

// NurseryID returns the "nursery" edge ID in the mutation.
func (m *ChildMutation) NurseryID() (id uuid.UUID, exists bool) {
	if m.nursery != nil {
		return *m.nursery, true
	}
	return
}

// NurseryIDs returns the "nursery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NurseryID instead. It exists only for internal usage by the builders.
func (m *ChildMutation) NurseryIDs() (ids []uuid.UUID) {
	if id := m.nursery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNursery resets all changes to the "nursery" edge.
func (m *ChildMutation) ResetNursery() {
	m.nursery = nil
	m.clearednursery = false
}

// AddBoardingRecordIDs adds the "boarding_record" edge to the BoardingRecord entity by ids.
func (m *ChildMutation) AddBoardingRecordIDs(ids ...uuid.UUID) {
	if m.boarding_record == nil {
		m.boarding_record = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.boarding_record[ids[i]] = struct{}{}
	}
}

// ClearBoardingRecord clears the "boarding_record" edge to the BoardingRecord entity.
func (m *ChildMutation) ClearBoardingRecord() {
	m.clearedboarding_record = true
}

// BoardingRecordCleared reports if the "boarding_record" edge to the BoardingRecord entity was cleared.
func (m *ChildMutation) BoardingRecordCleared() bool {
	return m.clearedboarding_record
}

// RemoveBoardingRecordIDs removes the "boarding_record" edge to the BoardingRecord entity by IDs.
func (m *ChildMutation) RemoveBoardingRecordIDs(ids ...uuid.UUID) {
	if m.removedboarding_record == nil {
		m.removedboarding_record = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.boarding_record, ids[i])
		m.removedboarding_record[ids[i]] = struct{}{}
	}
}

// RemovedBoardingRecord returns the removed IDs of the "boarding_record" edge to the BoardingRecord entity.
func (m *ChildMutation) RemovedBoardingRecordIDs() (ids []uuid.UUID) {
	for id := range m.removedboarding_record {
		ids = append(ids, id)
	}
	return
}

// BoardingRecordIDs returns the "boarding_record" edge IDs in the mutation.
func (m *ChildMutation) BoardingRecordIDs() (ids []uuid.UUID) {
	for id := range m.boarding_record {
		ids = append(ids, id)
	}
	return
}

// ResetBoardingRecord resets all changes to the "boarding_record" edge.
func (m *ChildMutation) ResetBoardingRecord() {
	m.boarding_record = nil
	m.clearedboarding_record = false
	m.removedboarding_record = nil
}

// AddPhotoIDs adds the "photos" edge to the ChildPhoto entity by ids.
func (m *ChildMutation) AddPhotoIDs(ids ...uuid.UUID) {
	if m.photos == nil {
		m.photos = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.photos[ids[i]] = struct{}{}
	}
}

// ClearPhotos clears the "photos" edge to the ChildPhoto entity.
func (m *ChildMutation) ClearPhotos() {
	m.clearedphotos = true
}

// PhotosCleared reports if the "photos" edge to the ChildPhoto entity was cleared.
func (m *ChildMutation) PhotosCleared() bool {
	return m.clearedphotos
}

// RemovePhotoIDs removes the "photos" edge to the ChildPhoto entity by IDs.
func (m *ChildMutation) RemovePhotoIDs(ids ...uuid.UUID) {
	if m.removedphotos == nil {
		m.removedphotos = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.photos, ids[i])
		m.removedphotos[ids[i]] = struct{}{}
	}
}

// RemovedPhotos returns the removed IDs of the "photos" edge to the ChildPhoto entity.
func (m *ChildMutation) RemovedPhotosIDs() (ids []uuid.UUID) {
	for id := range m.removedphotos {
		ids = append(ids, id)
	}
	return
}

// PhotosIDs returns the "photos" edge IDs in the mutation.
func (m *ChildMutation) PhotosIDs() (ids []uuid.UUID) {
	for id := range m.photos {
		ids = append(ids, id)
	}
	return
}

// ResetPhotos resets all changes to the "photos" edge.
func (m *ChildMutation) ResetPhotos() {
	m.photos = nil
	m.clearedphotos = false
	m.removedphotos = nil
}

// Where appends a list predicates to the ChildMutation builder.
func (m *ChildMutation) Where(ps ...predicate.Child) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChildMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChildMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Child, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChildMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChildMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Child).
func (m *ChildMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChildMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, child.FieldName)
	}
	if m.age != nil {
		fields = append(fields, child.FieldAge)
	}
	if m.sex != nil {
		fields = append(fields, child.FieldSex)
	}
	if m.is_ride_morning_bus != nil {
		fields = append(fields, child.FieldIsRideMorningBus)
	}
	if m.is_ride_evening_bus != nil {
		fields = append(fields, child.FieldIsRideEveningBus)
	}
	if m.check_for_missing_items != nil {
		fields = append(fields, child.FieldCheckForMissingItems)
	}
	if m.has_bag != nil {
		fields = append(fields, child.FieldHasBag)
	}
	if m.has_lunch_box != nil {
		fields = append(fields, child.FieldHasLunchBox)
	}
	if m.has_water_bottle != nil {
		fields = append(fields, child.FieldHasWaterBottle)
	}
	if m.has_umbrella != nil {
		fields = append(fields, child.FieldHasUmbrella)
	}
	if m.has_other != nil {
		fields = append(fields, child.FieldHasOther)
	}
	if m.created_at != nil {
		fields = append(fields, child.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, child.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChildMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case child.FieldName:
		return m.Name()
	case child.FieldAge:
		return m.Age()
	case child.FieldSex:
		return m.Sex()
	case child.FieldIsRideMorningBus:
		return m.IsRideMorningBus()
	case child.FieldIsRideEveningBus:
		return m.IsRideEveningBus()
	case child.FieldCheckForMissingItems:
		return m.CheckForMissingItems()
	case child.FieldHasBag:
		return m.HasBag()
	case child.FieldHasLunchBox:
		return m.HasLunchBox()
	case child.FieldHasWaterBottle:
		return m.HasWaterBottle()
	case child.FieldHasUmbrella:
		return m.HasUmbrella()
	case child.FieldHasOther:
		return m.HasOther()
	case child.FieldCreatedAt:
		return m.CreatedAt()
	case child.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChildMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case child.FieldName:
		return m.OldName(ctx)
	case child.FieldAge:
		return m.OldAge(ctx)
	case child.FieldSex:
		return m.OldSex(ctx)
	case child.FieldIsRideMorningBus:
		return m.OldIsRideMorningBus(ctx)
	case child.FieldIsRideEveningBus:
		return m.OldIsRideEveningBus(ctx)
	case child.FieldCheckForMissingItems:
		return m.OldCheckForMissingItems(ctx)
	case child.FieldHasBag:
		return m.OldHasBag(ctx)
	case child.FieldHasLunchBox:
		return m.OldHasLunchBox(ctx)
	case child.FieldHasWaterBottle:
		return m.OldHasWaterBottle(ctx)
	case child.FieldHasUmbrella:
		return m.OldHasUmbrella(ctx)
	case child.FieldHasOther:
		return m.OldHasOther(ctx)
	case child.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case child.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Child field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChildMutation) SetField(name string, value ent.Value) error {
	switch name {
	case child.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case child.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case child.FieldSex:
		v, ok := value.(child.Sex)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case child.FieldIsRideMorningBus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRideMorningBus(v)
		return nil
	case child.FieldIsRideEveningBus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRideEveningBus(v)
		return nil
	case child.FieldCheckForMissingItems:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckForMissingItems(v)
		return nil
	case child.FieldHasBag:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasBag(v)
		return nil
	case child.FieldHasLunchBox:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasLunchBox(v)
		return nil
	case child.FieldHasWaterBottle:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasWaterBottle(v)
		return nil
	case child.FieldHasUmbrella:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasUmbrella(v)
		return nil
	case child.FieldHasOther:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasOther(v)
		return nil
	case child.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case child.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Child field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChildMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, child.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChildMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case child.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChildMutation) AddField(name string, value ent.Value) error {
	switch name {
	case child.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown Child numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChildMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChildMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChildMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Child nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChildMutation) ResetField(name string) error {
	switch name {
	case child.FieldName:
		m.ResetName()
		return nil
	case child.FieldAge:
		m.ResetAge()
		return nil
	case child.FieldSex:
		m.ResetSex()
		return nil
	case child.FieldIsRideMorningBus:
		m.ResetIsRideMorningBus()
		return nil
	case child.FieldIsRideEveningBus:
		m.ResetIsRideEveningBus()
		return nil
	case child.FieldCheckForMissingItems:
		m.ResetCheckForMissingItems()
		return nil
	case child.FieldHasBag:
		m.ResetHasBag()
		return nil
	case child.FieldHasLunchBox:
		m.ResetHasLunchBox()
		return nil
	case child.FieldHasWaterBottle:
		m.ResetHasWaterBottle()
		return nil
	case child.FieldHasUmbrella:
		m.ResetHasUmbrella()
		return nil
	case child.FieldHasOther:
		m.ResetHasOther()
		return nil
	case child.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case child.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Child field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChildMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.guardian != nil {
		edges = append(edges, child.EdgeGuardian)
	}
	if m.childBusAssociations != nil {
		edges = append(edges, child.EdgeChildBusAssociations)
	}
	if m.nursery != nil {
		edges = append(edges, child.EdgeNursery)
	}
	if m.boarding_record != nil {
		edges = append(edges, child.EdgeBoardingRecord)
	}
	if m.photos != nil {
		edges = append(edges, child.EdgePhotos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChildMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case child.EdgeGuardian:
		if id := m.guardian; id != nil {
			return []ent.Value{*id}
		}
	case child.EdgeChildBusAssociations:
		ids := make([]ent.Value, 0, len(m.childBusAssociations))
		for id := range m.childBusAssociations {
			ids = append(ids, id)
		}
		return ids
	case child.EdgeNursery:
		if id := m.nursery; id != nil {
			return []ent.Value{*id}
		}
	case child.EdgeBoardingRecord:
		ids := make([]ent.Value, 0, len(m.boarding_record))
		for id := range m.boarding_record {
			ids = append(ids, id)
		}
		return ids
	case child.EdgePhotos:
		ids := make([]ent.Value, 0, len(m.photos))
		for id := range m.photos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChildMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedchildBusAssociations != nil {
		edges = append(edges, child.EdgeChildBusAssociations)
	}
	if m.removedboarding_record != nil {
		edges = append(edges, child.EdgeBoardingRecord)
	}
	if m.removedphotos != nil {
		edges = append(edges, child.EdgePhotos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChildMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case child.EdgeChildBusAssociations:
		ids := make([]ent.Value, 0, len(m.removedchildBusAssociations))
		for id := range m.removedchildBusAssociations {
			ids = append(ids, id)
		}
		return ids
	case child.EdgeBoardingRecord:
		ids := make([]ent.Value, 0, len(m.removedboarding_record))
		for id := range m.removedboarding_record {
			ids = append(ids, id)
		}
		return ids
	case child.EdgePhotos:
		ids := make([]ent.Value, 0, len(m.removedphotos))
		for id := range m.removedphotos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChildMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedguardian {
		edges = append(edges, child.EdgeGuardian)
	}
	if m.clearedchildBusAssociations {
		edges = append(edges, child.EdgeChildBusAssociations)
	}
	if m.clearednursery {
		edges = append(edges, child.EdgeNursery)
	}
	if m.clearedboarding_record {
		edges = append(edges, child.EdgeBoardingRecord)
	}
	if m.clearedphotos {
		edges = append(edges, child.EdgePhotos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChildMutation) EdgeCleared(name string) bool {
	switch name {
	case child.EdgeGuardian:
		return m.clearedguardian
	case child.EdgeChildBusAssociations:
		return m.clearedchildBusAssociations
	case child.EdgeNursery:
		return m.clearednursery
	case child.EdgeBoardingRecord:
		return m.clearedboarding_record
	case child.EdgePhotos:
		return m.clearedphotos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChildMutation) ClearEdge(name string) error {
	switch name {
	case child.EdgeGuardian:
		m.ClearGuardian()
		return nil
	case child.EdgeNursery:
		m.ClearNursery()
		return nil
	}
	return fmt.Errorf("unknown Child unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChildMutation) ResetEdge(name string) error {
	switch name {
	case child.EdgeGuardian:
		m.ResetGuardian()
		return nil
	case child.EdgeChildBusAssociations:
		m.ResetChildBusAssociations()
		return nil
	case child.EdgeNursery:
		m.ResetNursery()
		return nil
	case child.EdgeBoardingRecord:
		m.ResetBoardingRecord()
		return nil
	case child.EdgePhotos:
		m.ResetPhotos()
		return nil
	}
	return fmt.Errorf("unknown Child edge %s", name)
}

// ChildBusAssociationMutation represents an operation that mutates the ChildBusAssociation nodes in the graph.
type ChildBusAssociationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	bus_type      *childbusassociation.BusType
	clearedFields map[string]struct{}
	child         *uuid.UUID
	clearedchild  bool
	bus           *uuid.UUID
	clearedbus    bool
	done          bool
	oldValue      func(context.Context) (*ChildBusAssociation, error)
	predicates    []predicate.ChildBusAssociation
}

var _ ent.Mutation = (*ChildBusAssociationMutation)(nil)

// childbusassociationOption allows management of the mutation configuration using functional options.
type childbusassociationOption func(*ChildBusAssociationMutation)

// newChildBusAssociationMutation creates new mutation for the ChildBusAssociation entity.
func newChildBusAssociationMutation(c config, op Op, opts ...childbusassociationOption) *ChildBusAssociationMutation {
	m := &ChildBusAssociationMutation{
		config:        c,
		op:            op,
		typ:           TypeChildBusAssociation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChildBusAssociationID sets the ID field of the mutation.
func withChildBusAssociationID(id int) childbusassociationOption {
	return func(m *ChildBusAssociationMutation) {
		var (
			err   error
			once  sync.Once
			value *ChildBusAssociation
		)
		m.oldValue = func(ctx context.Context) (*ChildBusAssociation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChildBusAssociation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChildBusAssociation sets the old ChildBusAssociation of the mutation.
func withChildBusAssociation(node *ChildBusAssociation) childbusassociationOption {
	return func(m *ChildBusAssociationMutation) {
		m.oldValue = func(context.Context) (*ChildBusAssociation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChildBusAssociationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChildBusAssociationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChildBusAssociationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChildBusAssociationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChildBusAssociation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChildID sets the "child_id" field.
func (m *ChildBusAssociationMutation) SetChildID(u uuid.UUID) {
	m.child = &u
}

// ChildID returns the value of the "child_id" field in the mutation.
func (m *ChildBusAssociationMutation) ChildID() (r uuid.UUID, exists bool) {
	v := m.child
	if v == nil {
		return
	}
	return *v, true
}

// OldChildID returns the old "child_id" field's value of the ChildBusAssociation entity.
// If the ChildBusAssociation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildBusAssociationMutation) OldChildID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildID: %w", err)
	}
	return oldValue.ChildID, nil
}

// ResetChildID resets all changes to the "child_id" field.
func (m *ChildBusAssociationMutation) ResetChildID() {
	m.child = nil
}

// SetBusID sets the "bus_id" field.
func (m *ChildBusAssociationMutation) SetBusID(u uuid.UUID) {
	m.bus = &u
}

// BusID returns the value of the "bus_id" field in the mutation.
func (m *ChildBusAssociationMutation) BusID() (r uuid.UUID, exists bool) {
	v := m.bus
	if v == nil {
		return
	}
	return *v, true
}

// OldBusID returns the old "bus_id" field's value of the ChildBusAssociation entity.
// If the ChildBusAssociation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildBusAssociationMutation) OldBusID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusID: %w", err)
	}
	return oldValue.BusID, nil
}

// ResetBusID resets all changes to the "bus_id" field.
func (m *ChildBusAssociationMutation) ResetBusID() {
	m.bus = nil
}

// SetBusType sets the "bus_type" field.
func (m *ChildBusAssociationMutation) SetBusType(ct childbusassociation.BusType) {
	m.bus_type = &ct
}

// BusType returns the value of the "bus_type" field in the mutation.
func (m *ChildBusAssociationMutation) BusType() (r childbusassociation.BusType, exists bool) {
	v := m.bus_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBusType returns the old "bus_type" field's value of the ChildBusAssociation entity.
// If the ChildBusAssociation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildBusAssociationMutation) OldBusType(ctx context.Context) (v childbusassociation.BusType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusType: %w", err)
	}
	return oldValue.BusType, nil
}

// ResetBusType resets all changes to the "bus_type" field.
func (m *ChildBusAssociationMutation) ResetBusType() {
	m.bus_type = nil
}

// ClearChild clears the "child" edge to the Child entity.
func (m *ChildBusAssociationMutation) ClearChild() {
	m.clearedchild = true
	m.clearedFields[childbusassociation.FieldChildID] = struct{}{}
}

// ChildCleared reports if the "child" edge to the Child entity was cleared.
func (m *ChildBusAssociationMutation) ChildCleared() bool {
	return m.clearedchild
}

// ChildIDs returns the "child" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChildID instead. It exists only for internal usage by the builders.
func (m *ChildBusAssociationMutation) ChildIDs() (ids []uuid.UUID) {
	if id := m.child; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChild resets all changes to the "child" edge.
func (m *ChildBusAssociationMutation) ResetChild() {
	m.child = nil
	m.clearedchild = false
}

// ClearBus clears the "bus" edge to the Bus entity.
func (m *ChildBusAssociationMutation) ClearBus() {
	m.clearedbus = true
	m.clearedFields[childbusassociation.FieldBusID] = struct{}{}
}

// BusCleared reports if the "bus" edge to the Bus entity was cleared.
func (m *ChildBusAssociationMutation) BusCleared() bool {
	return m.clearedbus
}

// BusIDs returns the "bus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusID instead. It exists only for internal usage by the builders.
func (m *ChildBusAssociationMutation) BusIDs() (ids []uuid.UUID) {
	if id := m.bus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBus resets all changes to the "bus" edge.
func (m *ChildBusAssociationMutation) ResetBus() {
	m.bus = nil
	m.clearedbus = false
}

// Where appends a list predicates to the ChildBusAssociationMutation builder.
func (m *ChildBusAssociationMutation) Where(ps ...predicate.ChildBusAssociation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChildBusAssociationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChildBusAssociationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChildBusAssociation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChildBusAssociationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChildBusAssociationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChildBusAssociation).
func (m *ChildBusAssociationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChildBusAssociationMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.child != nil {
		fields = append(fields, childbusassociation.FieldChildID)
	}
	if m.bus != nil {
		fields = append(fields, childbusassociation.FieldBusID)
	}
	if m.bus_type != nil {
		fields = append(fields, childbusassociation.FieldBusType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChildBusAssociationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case childbusassociation.FieldChildID:
		return m.ChildID()
	case childbusassociation.FieldBusID:
		return m.BusID()
	case childbusassociation.FieldBusType:
		return m.BusType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChildBusAssociationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case childbusassociation.FieldChildID:
		return m.OldChildID(ctx)
	case childbusassociation.FieldBusID:
		return m.OldBusID(ctx)
	case childbusassociation.FieldBusType:
		return m.OldBusType(ctx)
	}
	return nil, fmt.Errorf("unknown ChildBusAssociation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChildBusAssociationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case childbusassociation.FieldChildID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildID(v)
		return nil
	case childbusassociation.FieldBusID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusID(v)
		return nil
	case childbusassociation.FieldBusType:
		v, ok := value.(childbusassociation.BusType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusType(v)
		return nil
	}
	return fmt.Errorf("unknown ChildBusAssociation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChildBusAssociationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChildBusAssociationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChildBusAssociationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ChildBusAssociation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChildBusAssociationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChildBusAssociationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChildBusAssociationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ChildBusAssociation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChildBusAssociationMutation) ResetField(name string) error {
	switch name {
	case childbusassociation.FieldChildID:
		m.ResetChildID()
		return nil
	case childbusassociation.FieldBusID:
		m.ResetBusID()
		return nil
	case childbusassociation.FieldBusType:
		m.ResetBusType()
		return nil
	}
	return fmt.Errorf("unknown ChildBusAssociation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChildBusAssociationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.child != nil {
		edges = append(edges, childbusassociation.EdgeChild)
	}
	if m.bus != nil {
		edges = append(edges, childbusassociation.EdgeBus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChildBusAssociationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case childbusassociation.EdgeChild:
		if id := m.child; id != nil {
			return []ent.Value{*id}
		}
	case childbusassociation.EdgeBus:
		if id := m.bus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChildBusAssociationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChildBusAssociationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChildBusAssociationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchild {
		edges = append(edges, childbusassociation.EdgeChild)
	}
	if m.clearedbus {
		edges = append(edges, childbusassociation.EdgeBus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChildBusAssociationMutation) EdgeCleared(name string) bool {
	switch name {
	case childbusassociation.EdgeChild:
		return m.clearedchild
	case childbusassociation.EdgeBus:
		return m.clearedbus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChildBusAssociationMutation) ClearEdge(name string) error {
	switch name {
	case childbusassociation.EdgeChild:
		m.ClearChild()
		return nil
	case childbusassociation.EdgeBus:
		m.ClearBus()
		return nil
	}
	return fmt.Errorf("unknown ChildBusAssociation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChildBusAssociationMutation) ResetEdge(name string) error {
	switch name {
	case childbusassociation.EdgeChild:
		m.ResetChild()
		return nil
	case childbusassociation.EdgeBus:
		m.ResetBus()
		return nil
	}
	return fmt.Errorf("unknown ChildBusAssociation edge %s", name)
}

// ChildPhotoMutation represents an operation that mutates the ChildPhoto nodes in the graph.
type ChildPhotoMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	s3_bucket     *string
	s3_key        *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	child         *uuid.UUID
	clearedchild  bool
	done          bool
	oldValue      func(context.Context) (*ChildPhoto, error)
	predicates    []predicate.ChildPhoto
}

var _ ent.Mutation = (*ChildPhotoMutation)(nil)

// childphotoOption allows management of the mutation configuration using functional options.
type childphotoOption func(*ChildPhotoMutation)

// newChildPhotoMutation creates new mutation for the ChildPhoto entity.
func newChildPhotoMutation(c config, op Op, opts ...childphotoOption) *ChildPhotoMutation {
	m := &ChildPhotoMutation{
		config:        c,
		op:            op,
		typ:           TypeChildPhoto,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChildPhotoID sets the ID field of the mutation.
func withChildPhotoID(id uuid.UUID) childphotoOption {
	return func(m *ChildPhotoMutation) {
		var (
			err   error
			once  sync.Once
			value *ChildPhoto
		)
		m.oldValue = func(ctx context.Context) (*ChildPhoto, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChildPhoto.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChildPhoto sets the old ChildPhoto of the mutation.
func withChildPhoto(node *ChildPhoto) childphotoOption {
	return func(m *ChildPhotoMutation) {
		m.oldValue = func(context.Context) (*ChildPhoto, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChildPhotoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChildPhotoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChildPhoto entities.
func (m *ChildPhotoMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChildPhotoMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChildPhotoMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChildPhoto.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetS3Bucket sets the "s3_bucket" field.
func (m *ChildPhotoMutation) SetS3Bucket(s string) {
	m.s3_bucket = &s
}

// S3Bucket returns the value of the "s3_bucket" field in the mutation.
func (m *ChildPhotoMutation) S3Bucket() (r string, exists bool) {
	v := m.s3_bucket
	if v == nil {
		return
	}
	return *v, true
}

// OldS3Bucket returns the old "s3_bucket" field's value of the ChildPhoto entity.
// If the ChildPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildPhotoMutation) OldS3Bucket(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3Bucket is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3Bucket requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3Bucket: %w", err)
	}
	return oldValue.S3Bucket, nil
}

// ResetS3Bucket resets all changes to the "s3_bucket" field.
func (m *ChildPhotoMutation) ResetS3Bucket() {
	m.s3_bucket = nil
}

// SetS3Key sets the "s3_key" field.
func (m *ChildPhotoMutation) SetS3Key(s string) {
	m.s3_key = &s
}

// S3Key returns the value of the "s3_key" field in the mutation.
func (m *ChildPhotoMutation) S3Key() (r string, exists bool) {
	v := m.s3_key
	if v == nil {
		return
	}
	return *v, true
}

// OldS3Key returns the old "s3_key" field's value of the ChildPhoto entity.
// If the ChildPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildPhotoMutation) OldS3Key(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3Key is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3Key requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3Key: %w", err)
	}
	return oldValue.S3Key, nil
}

// ResetS3Key resets all changes to the "s3_key" field.
func (m *ChildPhotoMutation) ResetS3Key() {
	m.s3_key = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ChildPhotoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChildPhotoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChildPhoto entity.
// If the ChildPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildPhotoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChildPhotoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChildPhotoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChildPhotoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChildPhoto entity.
// If the ChildPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChildPhotoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChildPhotoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetChildID sets the "child" edge to the Child entity by id.
func (m *ChildPhotoMutation) SetChildID(id uuid.UUID) {
	m.child = &id
}

// ClearChild clears the "child" edge to the Child entity.
func (m *ChildPhotoMutation) ClearChild() {
	m.clearedchild = true
}

// ChildCleared reports if the "child" edge to the Child entity was cleared.
func (m *ChildPhotoMutation) ChildCleared() bool {
	return m.clearedchild
}

// ChildID returns the "child" edge ID in the mutation.
func (m *ChildPhotoMutation) ChildID() (id uuid.UUID, exists bool) {
	if m.child != nil {
		return *m.child, true
	}
	return
}

// ChildIDs returns the "child" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChildID instead. It exists only for internal usage by the builders.
func (m *ChildPhotoMutation) ChildIDs() (ids []uuid.UUID) {
	if id := m.child; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChild resets all changes to the "child" edge.
func (m *ChildPhotoMutation) ResetChild() {
	m.child = nil
	m.clearedchild = false
}

// Where appends a list predicates to the ChildPhotoMutation builder.
func (m *ChildPhotoMutation) Where(ps ...predicate.ChildPhoto) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChildPhotoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChildPhotoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChildPhoto, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChildPhotoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChildPhotoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChildPhoto).
func (m *ChildPhotoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChildPhotoMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.s3_bucket != nil {
		fields = append(fields, childphoto.FieldS3Bucket)
	}
	if m.s3_key != nil {
		fields = append(fields, childphoto.FieldS3Key)
	}
	if m.created_at != nil {
		fields = append(fields, childphoto.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, childphoto.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChildPhotoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case childphoto.FieldS3Bucket:
		return m.S3Bucket()
	case childphoto.FieldS3Key:
		return m.S3Key()
	case childphoto.FieldCreatedAt:
		return m.CreatedAt()
	case childphoto.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChildPhotoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case childphoto.FieldS3Bucket:
		return m.OldS3Bucket(ctx)
	case childphoto.FieldS3Key:
		return m.OldS3Key(ctx)
	case childphoto.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case childphoto.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ChildPhoto field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChildPhotoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case childphoto.FieldS3Bucket:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3Bucket(v)
		return nil
	case childphoto.FieldS3Key:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3Key(v)
		return nil
	case childphoto.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case childphoto.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ChildPhoto field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChildPhotoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChildPhotoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChildPhotoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ChildPhoto numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChildPhotoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChildPhotoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChildPhotoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ChildPhoto nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChildPhotoMutation) ResetField(name string) error {
	switch name {
	case childphoto.FieldS3Bucket:
		m.ResetS3Bucket()
		return nil
	case childphoto.FieldS3Key:
		m.ResetS3Key()
		return nil
	case childphoto.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case childphoto.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ChildPhoto field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChildPhotoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.child != nil {
		edges = append(edges, childphoto.EdgeChild)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChildPhotoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case childphoto.EdgeChild:
		if id := m.child; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChildPhotoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChildPhotoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChildPhotoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchild {
		edges = append(edges, childphoto.EdgeChild)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChildPhotoMutation) EdgeCleared(name string) bool {
	switch name {
	case childphoto.EdgeChild:
		return m.clearedchild
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChildPhotoMutation) ClearEdge(name string) error {
	switch name {
	case childphoto.EdgeChild:
		m.ClearChild()
		return nil
	}
	return fmt.Errorf("unknown ChildPhoto unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChildPhotoMutation) ResetEdge(name string) error {
	switch name {
	case childphoto.EdgeChild:
		m.ResetChild()
		return nil
	}
	return fmt.Errorf("unknown ChildPhoto edge %s", name)
}

// GuardianMutation represents an operation that mutates the Guardian nodes in the graph.
type GuardianMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	email              *string
	encrypted_password *string
	name               *string
	phone_number       *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	children           map[uuid.UUID]struct{}
	removedchildren    map[uuid.UUID]struct{}
	clearedchildren    bool
	nursery            *uuid.UUID
	clearednursery     bool
	station            *uuid.UUID
	clearedstation     bool
	done               bool
	oldValue           func(context.Context) (*Guardian, error)
	predicates         []predicate.Guardian
}

var _ ent.Mutation = (*GuardianMutation)(nil)

// guardianOption allows management of the mutation configuration using functional options.
type guardianOption func(*GuardianMutation)

// newGuardianMutation creates new mutation for the Guardian entity.
func newGuardianMutation(c config, op Op, opts ...guardianOption) *GuardianMutation {
	m := &GuardianMutation{
		config:        c,
		op:            op,
		typ:           TypeGuardian,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGuardianID sets the ID field of the mutation.
func withGuardianID(id uuid.UUID) guardianOption {
	return func(m *GuardianMutation) {
		var (
			err   error
			once  sync.Once
			value *Guardian
		)
		m.oldValue = func(ctx context.Context) (*Guardian, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Guardian.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGuardian sets the old Guardian of the mutation.
func withGuardian(node *Guardian) guardianOption {
	return func(m *GuardianMutation) {
		m.oldValue = func(context.Context) (*Guardian, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GuardianMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GuardianMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Guardian entities.
func (m *GuardianMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GuardianMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GuardianMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Guardian.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *GuardianMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *GuardianMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Guardian entity.
// If the Guardian object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuardianMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *GuardianMutation) ResetEmail() {
	m.email = nil
}

// SetEncryptedPassword sets the "encrypted_password" field.
func (m *GuardianMutation) SetEncryptedPassword(s string) {
	m.encrypted_password = &s
}

// EncryptedPassword returns the value of the "encrypted_password" field in the mutation.
func (m *GuardianMutation) EncryptedPassword() (r string, exists bool) {
	v := m.encrypted_password
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptedPassword returns the old "encrypted_password" field's value of the Guardian entity.
// If the Guardian object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuardianMutation) OldEncryptedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptedPassword: %w", err)
	}
	return oldValue.EncryptedPassword, nil
}

// ResetEncryptedPassword resets all changes to the "encrypted_password" field.
func (m *GuardianMutation) ResetEncryptedPassword() {
	m.encrypted_password = nil
}

// SetName sets the "name" field.
func (m *GuardianMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GuardianMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Guardian entity.
// If the Guardian object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuardianMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GuardianMutation) ResetName() {
	m.name = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *GuardianMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *GuardianMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Guardian entity.
// If the Guardian object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuardianMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *GuardianMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[guardian.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *GuardianMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[guardian.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *GuardianMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, guardian.FieldPhoneNumber)
}

// SetCreatedAt sets the "created_at" field.
func (m *GuardianMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GuardianMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Guardian entity.
// If the Guardian object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuardianMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GuardianMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GuardianMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GuardianMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Guardian entity.
// If the Guardian object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuardianMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GuardianMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddChildIDs adds the "children" edge to the Child entity by ids.
func (m *GuardianMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Child entity.
func (m *GuardianMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Child entity was cleared.
func (m *GuardianMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Child entity by IDs.
func (m *GuardianMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Child entity.
func (m *GuardianMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *GuardianMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *GuardianMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetNurseryID sets the "nursery" edge to the Nursery entity by id.
func (m *GuardianMutation) SetNurseryID(id uuid.UUID) {
	m.nursery = &id
}

// ClearNursery clears the "nursery" edge to the Nursery entity.
func (m *GuardianMutation) ClearNursery() {
	m.clearednursery = true
}

// NurseryCleared reports if the "nursery" edge to the Nursery entity was cleared.
func (m *GuardianMutation) NurseryCleared() bool {
	return m.clearednursery
}

// NurseryID returns the "nursery" edge ID in the mutation.
func (m *GuardianMutation) NurseryID() (id uuid.UUID, exists bool) {
	if m.nursery != nil {
		return *m.nursery, true
	}
	return
}

// NurseryIDs returns the "nursery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NurseryID instead. It exists only for internal usage by the builders.
func (m *GuardianMutation) NurseryIDs() (ids []uuid.UUID) {
	if id := m.nursery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNursery resets all changes to the "nursery" edge.
func (m *GuardianMutation) ResetNursery() {
	m.nursery = nil
	m.clearednursery = false
}

// SetStationID sets the "station" edge to the Station entity by id.
func (m *GuardianMutation) SetStationID(id uuid.UUID) {
	m.station = &id
}

// ClearStation clears the "station" edge to the Station entity.
func (m *GuardianMutation) ClearStation() {
	m.clearedstation = true
}

// StationCleared reports if the "station" edge to the Station entity was cleared.
func (m *GuardianMutation) StationCleared() bool {
	return m.clearedstation
}

// StationID returns the "station" edge ID in the mutation.
func (m *GuardianMutation) StationID() (id uuid.UUID, exists bool) {
	if m.station != nil {
		return *m.station, true
	}
	return
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *GuardianMutation) StationIDs() (ids []uuid.UUID) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *GuardianMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// Where appends a list predicates to the GuardianMutation builder.
func (m *GuardianMutation) Where(ps ...predicate.Guardian) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GuardianMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GuardianMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Guardian, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GuardianMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GuardianMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Guardian).
func (m *GuardianMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GuardianMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.email != nil {
		fields = append(fields, guardian.FieldEmail)
	}
	if m.encrypted_password != nil {
		fields = append(fields, guardian.FieldEncryptedPassword)
	}
	if m.name != nil {
		fields = append(fields, guardian.FieldName)
	}
	if m.phone_number != nil {
		fields = append(fields, guardian.FieldPhoneNumber)
	}
	if m.created_at != nil {
		fields = append(fields, guardian.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, guardian.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GuardianMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case guardian.FieldEmail:
		return m.Email()
	case guardian.FieldEncryptedPassword:
		return m.EncryptedPassword()
	case guardian.FieldName:
		return m.Name()
	case guardian.FieldPhoneNumber:
		return m.PhoneNumber()
	case guardian.FieldCreatedAt:
		return m.CreatedAt()
	case guardian.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GuardianMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case guardian.FieldEmail:
		return m.OldEmail(ctx)
	case guardian.FieldEncryptedPassword:
		return m.OldEncryptedPassword(ctx)
	case guardian.FieldName:
		return m.OldName(ctx)
	case guardian.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case guardian.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case guardian.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Guardian field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GuardianMutation) SetField(name string, value ent.Value) error {
	switch name {
	case guardian.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case guardian.FieldEncryptedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptedPassword(v)
		return nil
	case guardian.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case guardian.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case guardian.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case guardian.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Guardian field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GuardianMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GuardianMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GuardianMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Guardian numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GuardianMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(guardian.FieldPhoneNumber) {
		fields = append(fields, guardian.FieldPhoneNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GuardianMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GuardianMutation) ClearField(name string) error {
	switch name {
	case guardian.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown Guardian nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GuardianMutation) ResetField(name string) error {
	switch name {
	case guardian.FieldEmail:
		m.ResetEmail()
		return nil
	case guardian.FieldEncryptedPassword:
		m.ResetEncryptedPassword()
		return nil
	case guardian.FieldName:
		m.ResetName()
		return nil
	case guardian.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case guardian.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case guardian.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Guardian field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GuardianMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.children != nil {
		edges = append(edges, guardian.EdgeChildren)
	}
	if m.nursery != nil {
		edges = append(edges, guardian.EdgeNursery)
	}
	if m.station != nil {
		edges = append(edges, guardian.EdgeStation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GuardianMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case guardian.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case guardian.EdgeNursery:
		if id := m.nursery; id != nil {
			return []ent.Value{*id}
		}
	case guardian.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GuardianMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, guardian.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GuardianMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case guardian.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GuardianMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchildren {
		edges = append(edges, guardian.EdgeChildren)
	}
	if m.clearednursery {
		edges = append(edges, guardian.EdgeNursery)
	}
	if m.clearedstation {
		edges = append(edges, guardian.EdgeStation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GuardianMutation) EdgeCleared(name string) bool {
	switch name {
	case guardian.EdgeChildren:
		return m.clearedchildren
	case guardian.EdgeNursery:
		return m.clearednursery
	case guardian.EdgeStation:
		return m.clearedstation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GuardianMutation) ClearEdge(name string) error {
	switch name {
	case guardian.EdgeNursery:
		m.ClearNursery()
		return nil
	case guardian.EdgeStation:
		m.ClearStation()
		return nil
	}
	return fmt.Errorf("unknown Guardian unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GuardianMutation) ResetEdge(name string) error {
	switch name {
	case guardian.EdgeChildren:
		m.ResetChildren()
		return nil
	case guardian.EdgeNursery:
		m.ResetNursery()
		return nil
	case guardian.EdgeStation:
		m.ResetStation()
		return nil
	}
	return fmt.Errorf("unknown Guardian edge %s", name)
}

// NurseryMutation represents an operation that mutates the Nursery nodes in the graph.
type NurseryMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	nursery_code       *string
	email              *string
	encrypted_password *string
	name               *string
	address            *string
	phone_number       *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	children           map[uuid.UUID]struct{}
	removedchildren    map[uuid.UUID]struct{}
	clearedchildren    bool
	guardians          map[uuid.UUID]struct{}
	removedguardians   map[uuid.UUID]struct{}
	clearedguardians   bool
	buses              map[uuid.UUID]struct{}
	removedbuses       map[uuid.UUID]struct{}
	clearedbuses       bool
	done               bool
	oldValue           func(context.Context) (*Nursery, error)
	predicates         []predicate.Nursery
}

var _ ent.Mutation = (*NurseryMutation)(nil)

// nurseryOption allows management of the mutation configuration using functional options.
type nurseryOption func(*NurseryMutation)

// newNurseryMutation creates new mutation for the Nursery entity.
func newNurseryMutation(c config, op Op, opts ...nurseryOption) *NurseryMutation {
	m := &NurseryMutation{
		config:        c,
		op:            op,
		typ:           TypeNursery,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNurseryID sets the ID field of the mutation.
func withNurseryID(id uuid.UUID) nurseryOption {
	return func(m *NurseryMutation) {
		var (
			err   error
			once  sync.Once
			value *Nursery
		)
		m.oldValue = func(ctx context.Context) (*Nursery, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Nursery.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNursery sets the old Nursery of the mutation.
func withNursery(node *Nursery) nurseryOption {
	return func(m *NurseryMutation) {
		m.oldValue = func(context.Context) (*Nursery, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NurseryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NurseryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Nursery entities.
func (m *NurseryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NurseryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NurseryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Nursery.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNurseryCode sets the "nursery_code" field.
func (m *NurseryMutation) SetNurseryCode(s string) {
	m.nursery_code = &s
}

// NurseryCode returns the value of the "nursery_code" field in the mutation.
func (m *NurseryMutation) NurseryCode() (r string, exists bool) {
	v := m.nursery_code
	if v == nil {
		return
	}
	return *v, true
}

// OldNurseryCode returns the old "nursery_code" field's value of the Nursery entity.
// If the Nursery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseryMutation) OldNurseryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNurseryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNurseryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNurseryCode: %w", err)
	}
	return oldValue.NurseryCode, nil
}

// ResetNurseryCode resets all changes to the "nursery_code" field.
func (m *NurseryMutation) ResetNurseryCode() {
	m.nursery_code = nil
}

// SetEmail sets the "email" field.
func (m *NurseryMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *NurseryMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Nursery entity.
// If the Nursery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseryMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *NurseryMutation) ResetEmail() {
	m.email = nil
}

// SetEncryptedPassword sets the "encrypted_password" field.
func (m *NurseryMutation) SetEncryptedPassword(s string) {
	m.encrypted_password = &s
}

// EncryptedPassword returns the value of the "encrypted_password" field in the mutation.
func (m *NurseryMutation) EncryptedPassword() (r string, exists bool) {
	v := m.encrypted_password
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptedPassword returns the old "encrypted_password" field's value of the Nursery entity.
// If the Nursery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseryMutation) OldEncryptedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptedPassword: %w", err)
	}
	return oldValue.EncryptedPassword, nil
}

// ResetEncryptedPassword resets all changes to the "encrypted_password" field.
func (m *NurseryMutation) ResetEncryptedPassword() {
	m.encrypted_password = nil
}

// SetName sets the "name" field.
func (m *NurseryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NurseryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Nursery entity.
// If the Nursery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NurseryMutation) ResetName() {
	m.name = nil
}

// SetAddress sets the "address" field.
func (m *NurseryMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *NurseryMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Nursery entity.
// If the Nursery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseryMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *NurseryMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[nursery.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *NurseryMutation) AddressCleared() bool {
	_, ok := m.clearedFields[nursery.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *NurseryMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, nursery.FieldAddress)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *NurseryMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *NurseryMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Nursery entity.
// If the Nursery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseryMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *NurseryMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[nursery.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *NurseryMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[nursery.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *NurseryMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, nursery.FieldPhoneNumber)
}

// SetCreatedAt sets the "created_at" field.
func (m *NurseryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NurseryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Nursery entity.
// If the Nursery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NurseryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NurseryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NurseryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Nursery entity.
// If the Nursery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NurseryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddChildIDs adds the "children" edge to the Child entity by ids.
func (m *NurseryMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Child entity.
func (m *NurseryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Child entity was cleared.
func (m *NurseryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Child entity by IDs.
func (m *NurseryMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Child entity.
func (m *NurseryMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *NurseryMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *NurseryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddGuardianIDs adds the "guardians" edge to the Guardian entity by ids.
func (m *NurseryMutation) AddGuardianIDs(ids ...uuid.UUID) {
	if m.guardians == nil {
		m.guardians = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.guardians[ids[i]] = struct{}{}
	}
}

// ClearGuardians clears the "guardians" edge to the Guardian entity.
func (m *NurseryMutation) ClearGuardians() {
	m.clearedguardians = true
}

// GuardiansCleared reports if the "guardians" edge to the Guardian entity was cleared.
func (m *NurseryMutation) GuardiansCleared() bool {
	return m.clearedguardians
}

// RemoveGuardianIDs removes the "guardians" edge to the Guardian entity by IDs.
func (m *NurseryMutation) RemoveGuardianIDs(ids ...uuid.UUID) {
	if m.removedguardians == nil {
		m.removedguardians = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.guardians, ids[i])
		m.removedguardians[ids[i]] = struct{}{}
	}
}

// RemovedGuardians returns the removed IDs of the "guardians" edge to the Guardian entity.
func (m *NurseryMutation) RemovedGuardiansIDs() (ids []uuid.UUID) {
	for id := range m.removedguardians {
		ids = append(ids, id)
	}
	return
}

// GuardiansIDs returns the "guardians" edge IDs in the mutation.
func (m *NurseryMutation) GuardiansIDs() (ids []uuid.UUID) {
	for id := range m.guardians {
		ids = append(ids, id)
	}
	return
}

// ResetGuardians resets all changes to the "guardians" edge.
func (m *NurseryMutation) ResetGuardians() {
	m.guardians = nil
	m.clearedguardians = false
	m.removedguardians = nil
}

// AddBusIDs adds the "buses" edge to the Bus entity by ids.
func (m *NurseryMutation) AddBusIDs(ids ...uuid.UUID) {
	if m.buses == nil {
		m.buses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.buses[ids[i]] = struct{}{}
	}
}

// ClearBuses clears the "buses" edge to the Bus entity.
func (m *NurseryMutation) ClearBuses() {
	m.clearedbuses = true
}

// BusesCleared reports if the "buses" edge to the Bus entity was cleared.
func (m *NurseryMutation) BusesCleared() bool {
	return m.clearedbuses
}

// RemoveBusIDs removes the "buses" edge to the Bus entity by IDs.
func (m *NurseryMutation) RemoveBusIDs(ids ...uuid.UUID) {
	if m.removedbuses == nil {
		m.removedbuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.buses, ids[i])
		m.removedbuses[ids[i]] = struct{}{}
	}
}

// RemovedBuses returns the removed IDs of the "buses" edge to the Bus entity.
func (m *NurseryMutation) RemovedBusesIDs() (ids []uuid.UUID) {
	for id := range m.removedbuses {
		ids = append(ids, id)
	}
	return
}

// BusesIDs returns the "buses" edge IDs in the mutation.
func (m *NurseryMutation) BusesIDs() (ids []uuid.UUID) {
	for id := range m.buses {
		ids = append(ids, id)
	}
	return
}

// ResetBuses resets all changes to the "buses" edge.
func (m *NurseryMutation) ResetBuses() {
	m.buses = nil
	m.clearedbuses = false
	m.removedbuses = nil
}

// Where appends a list predicates to the NurseryMutation builder.
func (m *NurseryMutation) Where(ps ...predicate.Nursery) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NurseryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NurseryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Nursery, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NurseryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NurseryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Nursery).
func (m *NurseryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NurseryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.nursery_code != nil {
		fields = append(fields, nursery.FieldNurseryCode)
	}
	if m.email != nil {
		fields = append(fields, nursery.FieldEmail)
	}
	if m.encrypted_password != nil {
		fields = append(fields, nursery.FieldEncryptedPassword)
	}
	if m.name != nil {
		fields = append(fields, nursery.FieldName)
	}
	if m.address != nil {
		fields = append(fields, nursery.FieldAddress)
	}
	if m.phone_number != nil {
		fields = append(fields, nursery.FieldPhoneNumber)
	}
	if m.created_at != nil {
		fields = append(fields, nursery.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, nursery.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NurseryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nursery.FieldNurseryCode:
		return m.NurseryCode()
	case nursery.FieldEmail:
		return m.Email()
	case nursery.FieldEncryptedPassword:
		return m.EncryptedPassword()
	case nursery.FieldName:
		return m.Name()
	case nursery.FieldAddress:
		return m.Address()
	case nursery.FieldPhoneNumber:
		return m.PhoneNumber()
	case nursery.FieldCreatedAt:
		return m.CreatedAt()
	case nursery.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NurseryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nursery.FieldNurseryCode:
		return m.OldNurseryCode(ctx)
	case nursery.FieldEmail:
		return m.OldEmail(ctx)
	case nursery.FieldEncryptedPassword:
		return m.OldEncryptedPassword(ctx)
	case nursery.FieldName:
		return m.OldName(ctx)
	case nursery.FieldAddress:
		return m.OldAddress(ctx)
	case nursery.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case nursery.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case nursery.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Nursery field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NurseryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nursery.FieldNurseryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNurseryCode(v)
		return nil
	case nursery.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case nursery.FieldEncryptedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptedPassword(v)
		return nil
	case nursery.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case nursery.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case nursery.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case nursery.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case nursery.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Nursery field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NurseryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NurseryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NurseryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Nursery numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NurseryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(nursery.FieldAddress) {
		fields = append(fields, nursery.FieldAddress)
	}
	if m.FieldCleared(nursery.FieldPhoneNumber) {
		fields = append(fields, nursery.FieldPhoneNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NurseryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NurseryMutation) ClearField(name string) error {
	switch name {
	case nursery.FieldAddress:
		m.ClearAddress()
		return nil
	case nursery.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown Nursery nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NurseryMutation) ResetField(name string) error {
	switch name {
	case nursery.FieldNurseryCode:
		m.ResetNurseryCode()
		return nil
	case nursery.FieldEmail:
		m.ResetEmail()
		return nil
	case nursery.FieldEncryptedPassword:
		m.ResetEncryptedPassword()
		return nil
	case nursery.FieldName:
		m.ResetName()
		return nil
	case nursery.FieldAddress:
		m.ResetAddress()
		return nil
	case nursery.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case nursery.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case nursery.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Nursery field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NurseryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.children != nil {
		edges = append(edges, nursery.EdgeChildren)
	}
	if m.guardians != nil {
		edges = append(edges, nursery.EdgeGuardians)
	}
	if m.buses != nil {
		edges = append(edges, nursery.EdgeBuses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NurseryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nursery.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case nursery.EdgeGuardians:
		ids := make([]ent.Value, 0, len(m.guardians))
		for id := range m.guardians {
			ids = append(ids, id)
		}
		return ids
	case nursery.EdgeBuses:
		ids := make([]ent.Value, 0, len(m.buses))
		for id := range m.buses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NurseryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, nursery.EdgeChildren)
	}
	if m.removedguardians != nil {
		edges = append(edges, nursery.EdgeGuardians)
	}
	if m.removedbuses != nil {
		edges = append(edges, nursery.EdgeBuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NurseryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nursery.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case nursery.EdgeGuardians:
		ids := make([]ent.Value, 0, len(m.removedguardians))
		for id := range m.removedguardians {
			ids = append(ids, id)
		}
		return ids
	case nursery.EdgeBuses:
		ids := make([]ent.Value, 0, len(m.removedbuses))
		for id := range m.removedbuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NurseryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchildren {
		edges = append(edges, nursery.EdgeChildren)
	}
	if m.clearedguardians {
		edges = append(edges, nursery.EdgeGuardians)
	}
	if m.clearedbuses {
		edges = append(edges, nursery.EdgeBuses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NurseryMutation) EdgeCleared(name string) bool {
	switch name {
	case nursery.EdgeChildren:
		return m.clearedchildren
	case nursery.EdgeGuardians:
		return m.clearedguardians
	case nursery.EdgeBuses:
		return m.clearedbuses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NurseryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Nursery unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NurseryMutation) ResetEdge(name string) error {
	switch name {
	case nursery.EdgeChildren:
		m.ResetChildren()
		return nil
	case nursery.EdgeGuardians:
		m.ResetGuardians()
		return nil
	case nursery.EdgeBuses:
		m.ResetBuses()
		return nil
	}
	return fmt.Errorf("unknown Nursery edge %s", name)
}

// StationMutation represents an operation that mutates the Station nodes in the graph.
type StationMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	latitude         *float64
	addlatitude      *float64
	longitude        *float64
	addlongitude     *float64
	morning_order    *int
	addmorning_order *int
	evening_order    *int
	addevening_order *int
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	guardian         *uuid.UUID
	clearedguardian  bool
	bus              map[uuid.UUID]struct{}
	removedbus       map[uuid.UUID]struct{}
	clearedbus       bool
	done             bool
	oldValue         func(context.Context) (*Station, error)
	predicates       []predicate.Station
}

var _ ent.Mutation = (*StationMutation)(nil)

// stationOption allows management of the mutation configuration using functional options.
type stationOption func(*StationMutation)

// newStationMutation creates new mutation for the Station entity.
func newStationMutation(c config, op Op, opts ...stationOption) *StationMutation {
	m := &StationMutation{
		config:        c,
		op:            op,
		typ:           TypeStation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStationID sets the ID field of the mutation.
func withStationID(id uuid.UUID) stationOption {
	return func(m *StationMutation) {
		var (
			err   error
			once  sync.Once
			value *Station
		)
		m.oldValue = func(ctx context.Context) (*Station, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Station.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStation sets the old Station of the mutation.
func withStation(node *Station) stationOption {
	return func(m *StationMutation) {
		m.oldValue = func(context.Context) (*Station, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Station entities.
func (m *StationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Station.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLatitude sets the "latitude" field.
func (m *StationMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *StationMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *StationMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *StationMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *StationMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[station.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *StationMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[station.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *StationMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, station.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *StationMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *StationMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *StationMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *StationMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *StationMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[station.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *StationMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[station.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *StationMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, station.FieldLongitude)
}

// SetMorningOrder sets the "morning_order" field.
func (m *StationMutation) SetMorningOrder(i int) {
	m.morning_order = &i
	m.addmorning_order = nil
}

// MorningOrder returns the value of the "morning_order" field in the mutation.
func (m *StationMutation) MorningOrder() (r int, exists bool) {
	v := m.morning_order
	if v == nil {
		return
	}
	return *v, true
}

// OldMorningOrder returns the old "morning_order" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldMorningOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMorningOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMorningOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMorningOrder: %w", err)
	}
	return oldValue.MorningOrder, nil
}

// AddMorningOrder adds i to the "morning_order" field.
func (m *StationMutation) AddMorningOrder(i int) {
	if m.addmorning_order != nil {
		*m.addmorning_order += i
	} else {
		m.addmorning_order = &i
	}
}

// AddedMorningOrder returns the value that was added to the "morning_order" field in this mutation.
func (m *StationMutation) AddedMorningOrder() (r int, exists bool) {
	v := m.addmorning_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetMorningOrder resets all changes to the "morning_order" field.
func (m *StationMutation) ResetMorningOrder() {
	m.morning_order = nil
	m.addmorning_order = nil
}

// SetEveningOrder sets the "evening_order" field.
func (m *StationMutation) SetEveningOrder(i int) {
	m.evening_order = &i
	m.addevening_order = nil
}

// EveningOrder returns the value of the "evening_order" field in the mutation.
func (m *StationMutation) EveningOrder() (r int, exists bool) {
	v := m.evening_order
	if v == nil {
		return
	}
	return *v, true
}

// OldEveningOrder returns the old "evening_order" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldEveningOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEveningOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEveningOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEveningOrder: %w", err)
	}
	return oldValue.EveningOrder, nil
}

// AddEveningOrder adds i to the "evening_order" field.
func (m *StationMutation) AddEveningOrder(i int) {
	if m.addevening_order != nil {
		*m.addevening_order += i
	} else {
		m.addevening_order = &i
	}
}

// AddedEveningOrder returns the value that was added to the "evening_order" field in this mutation.
func (m *StationMutation) AddedEveningOrder() (r int, exists bool) {
	v := m.addevening_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetEveningOrder resets all changes to the "evening_order" field.
func (m *StationMutation) ResetEveningOrder() {
	m.evening_order = nil
	m.addevening_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetGuardianID sets the "guardian" edge to the Guardian entity by id.
func (m *StationMutation) SetGuardianID(id uuid.UUID) {
	m.guardian = &id
}

// ClearGuardian clears the "guardian" edge to the Guardian entity.
func (m *StationMutation) ClearGuardian() {
	m.clearedguardian = true
}

// GuardianCleared reports if the "guardian" edge to the Guardian entity was cleared.
func (m *StationMutation) GuardianCleared() bool {
	return m.clearedguardian
}

// GuardianID returns the "guardian" edge ID in the mutation.
func (m *StationMutation) GuardianID() (id uuid.UUID, exists bool) {
	if m.guardian != nil {
		return *m.guardian, true
	}
	return
}

// GuardianIDs returns the "guardian" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GuardianID instead. It exists only for internal usage by the builders.
func (m *StationMutation) GuardianIDs() (ids []uuid.UUID) {
	if id := m.guardian; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGuardian resets all changes to the "guardian" edge.
func (m *StationMutation) ResetGuardian() {
	m.guardian = nil
	m.clearedguardian = false
}

// AddBuIDs adds the "bus" edge to the Bus entity by ids.
func (m *StationMutation) AddBuIDs(ids ...uuid.UUID) {
	if m.bus == nil {
		m.bus = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bus[ids[i]] = struct{}{}
	}
}

// ClearBus clears the "bus" edge to the Bus entity.
func (m *StationMutation) ClearBus() {
	m.clearedbus = true
}

// BusCleared reports if the "bus" edge to the Bus entity was cleared.
func (m *StationMutation) BusCleared() bool {
	return m.clearedbus
}

// RemoveBuIDs removes the "bus" edge to the Bus entity by IDs.
func (m *StationMutation) RemoveBuIDs(ids ...uuid.UUID) {
	if m.removedbus == nil {
		m.removedbus = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bus, ids[i])
		m.removedbus[ids[i]] = struct{}{}
	}
}

// RemovedBus returns the removed IDs of the "bus" edge to the Bus entity.
func (m *StationMutation) RemovedBusIDs() (ids []uuid.UUID) {
	for id := range m.removedbus {
		ids = append(ids, id)
	}
	return
}

// BusIDs returns the "bus" edge IDs in the mutation.
func (m *StationMutation) BusIDs() (ids []uuid.UUID) {
	for id := range m.bus {
		ids = append(ids, id)
	}
	return
}

// ResetBus resets all changes to the "bus" edge.
func (m *StationMutation) ResetBus() {
	m.bus = nil
	m.clearedbus = false
	m.removedbus = nil
}

// Where appends a list predicates to the StationMutation builder.
func (m *StationMutation) Where(ps ...predicate.Station) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Station, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Station).
func (m *StationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.latitude != nil {
		fields = append(fields, station.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, station.FieldLongitude)
	}
	if m.morning_order != nil {
		fields = append(fields, station.FieldMorningOrder)
	}
	if m.evening_order != nil {
		fields = append(fields, station.FieldEveningOrder)
	}
	if m.created_at != nil {
		fields = append(fields, station.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, station.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case station.FieldLatitude:
		return m.Latitude()
	case station.FieldLongitude:
		return m.Longitude()
	case station.FieldMorningOrder:
		return m.MorningOrder()
	case station.FieldEveningOrder:
		return m.EveningOrder()
	case station.FieldCreatedAt:
		return m.CreatedAt()
	case station.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case station.FieldLatitude:
		return m.OldLatitude(ctx)
	case station.FieldLongitude:
		return m.OldLongitude(ctx)
	case station.FieldMorningOrder:
		return m.OldMorningOrder(ctx)
	case station.FieldEveningOrder:
		return m.OldEveningOrder(ctx)
	case station.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case station.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Station field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case station.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case station.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case station.FieldMorningOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMorningOrder(v)
		return nil
	case station.FieldEveningOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEveningOrder(v)
		return nil
	case station.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case station.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Station field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StationMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, station.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, station.FieldLongitude)
	}
	if m.addmorning_order != nil {
		fields = append(fields, station.FieldMorningOrder)
	}
	if m.addevening_order != nil {
		fields = append(fields, station.FieldEveningOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case station.FieldLatitude:
		return m.AddedLatitude()
	case station.FieldLongitude:
		return m.AddedLongitude()
	case station.FieldMorningOrder:
		return m.AddedMorningOrder()
	case station.FieldEveningOrder:
		return m.AddedEveningOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case station.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case station.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case station.FieldMorningOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMorningOrder(v)
		return nil
	case station.FieldEveningOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEveningOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Station numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(station.FieldLatitude) {
		fields = append(fields, station.FieldLatitude)
	}
	if m.FieldCleared(station.FieldLongitude) {
		fields = append(fields, station.FieldLongitude)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StationMutation) ClearField(name string) error {
	switch name {
	case station.FieldLatitude:
		m.ClearLatitude()
		return nil
	case station.FieldLongitude:
		m.ClearLongitude()
		return nil
	}
	return fmt.Errorf("unknown Station nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StationMutation) ResetField(name string) error {
	switch name {
	case station.FieldLatitude:
		m.ResetLatitude()
		return nil
	case station.FieldLongitude:
		m.ResetLongitude()
		return nil
	case station.FieldMorningOrder:
		m.ResetMorningOrder()
		return nil
	case station.FieldEveningOrder:
		m.ResetEveningOrder()
		return nil
	case station.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case station.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Station field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.guardian != nil {
		edges = append(edges, station.EdgeGuardian)
	}
	if m.bus != nil {
		edges = append(edges, station.EdgeBus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case station.EdgeGuardian:
		if id := m.guardian; id != nil {
			return []ent.Value{*id}
		}
	case station.EdgeBus:
		ids := make([]ent.Value, 0, len(m.bus))
		for id := range m.bus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbus != nil {
		edges = append(edges, station.EdgeBus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case station.EdgeBus:
		ids := make([]ent.Value, 0, len(m.removedbus))
		for id := range m.removedbus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedguardian {
		edges = append(edges, station.EdgeGuardian)
	}
	if m.clearedbus {
		edges = append(edges, station.EdgeBus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StationMutation) EdgeCleared(name string) bool {
	switch name {
	case station.EdgeGuardian:
		return m.clearedguardian
	case station.EdgeBus:
		return m.clearedbus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StationMutation) ClearEdge(name string) error {
	switch name {
	case station.EdgeGuardian:
		m.ClearGuardian()
		return nil
	}
	return fmt.Errorf("unknown Station unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StationMutation) ResetEdge(name string) error {
	switch name {
	case station.EdgeGuardian:
		m.ResetGuardian()
		return nil
	case station.EdgeBus:
		m.ResetBus()
		return nil
	}
	return fmt.Errorf("unknown Station edge %s", name)
}
